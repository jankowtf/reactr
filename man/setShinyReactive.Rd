% Generated by roxygen2 (4.0.2): do not edit by hand
\name{setShinyReactive}
\alias{setShinyReactive}
\title{Set Reactive Object with Shiny Functionality (S3)}
\usage{
setShinyReactive(id, value = NULL, where = parent.frame(), ...)
}
\arguments{
\item{id}{\code{\link{character}}.
Name/ID of the reactive object to set.}

\item{value}{\code{\link{ANY}}.
Value or reactive binding.}

\item{where}{\code{\link{environment}}.
Environment in which to create the object.}

\item{...}{Further arguments to be passed to subsequent functions/methods.}
}
\description{
Creates an reactive object as the ones created by the
\href{shiny}{http://shiny.rstudio.com/} framework/package.
}
\details{
The function makes explicit use of \code{\link[shiny]{makeReactiveBinding}}
and \code{\link[shiny]{reactive}}. This implies, that the entire reactive
paradigm underlying the shiny framework is also used.
For the most relevant aspects of this see:

\itemize{
   \item{Creating an object that can have reactive bindings: } {
       \itemize{
         \item{Function \code{\link[shiny]{reactiveValues}}}
         \item{Function \code{\link[shiny]{.createReactiveValues}}}
         \item{R6 class \code{\link[shiny]{ReactiveValues}}}
       }
   }
   \item{Creating an object that has reactive bindings: } {
       \itemize{
         \item{Function \code{\link[shiny]{reactive}}}
         \item{R6 class \code{\link[shiny]{Observable}}}
         \item{R6 class \code{\link[shiny]{Map}}}
       }
   }
}

Note that the function creates the object with name \code{id} in environment
\code{where}. So you don't explicitly need to assign
the return value to \code{id}. Of course you can also do so as well.
}
\section{Remarks with respect to mutual reactive bindings}{


To the best of my knowledge, the reactive paradigm implemented by the
shiny framework does not offer the possibility to define mutual reactive
bindings.

Thus, something like \code{x_1} has reactive binding \code{reactive{x_2 * 2}}
and \code{x_2} has reactive binding \code{reactive{x_1 / 2}} where \strong{both} objects can be
modified via \code{\link{<-}} can not be specified. The reason for this is
that reactivity is implemented in a direct or immediate manner: whenever
\code{x_1} that has a reactive binding to \code{x_2} is requested, it runs
its reactive binding function even though \code{x_2} might not have changed
at all. Thus, mutual reactive bindings of the above form result in an
infinite recursion.

If you would like to define mutual reactive bindings, you currently need to
use \code{\link[reactr]{setReactiveS3}} as it implements a value caching
mechanism that allows reactive functions only to be triggered when actually
needed, i.e. when the referenced object has actually changed.
}

\section{Outlook with respect to the integration of shiny functionality}{


Currently, at the end of the day the function does little more than
providing a wrapper for \code{\link[base]{makeActiveBinding}} to the
functionality offered by shiny. As shiny itself implements sort of the
reactive version of \code{\link[base]{makeActiveBinding}},
\code{\link[shiny]{makeReactiveBinding}} already, it is very likely that
these two approaches can and will be merged in future releases.

Also, adding a similar caching mechansims as the one implemented by
\code{\link[reactr]{setReactiveS3}} seems possible.
}
\examples{
\dontrun{
  
##------------------------------------------------------------------------------  
## Set reactive objects in parent environment //
##------------------------------------------------------------------------------

## Set object that other objects can have reactive bindings to //
setShinyReactive(id = "x_1", value = Sys.time())
## --> 'x_1' is set in 'environment()' so you don't explicitly need to assign
## the return value of 'shinyRective()'  to 'x_1'. Of course you can also do so:
x_1
x_1 <- setShinyReactive(id = "x_1", value = Sys.time())
x_1 <- Sys.time()
x_1

## Set object with reactive bindings to 'x_1' //
setShinyReactive(id = "x_2", value = reactive(x_1 + 60*60*24))
x_2
## --> 'x_1' + one day
(x_1 <- Sys.time())
x_2
## --> reactive

## Clean up //
suppressWarnings(rm(x_1))
suppressWarnings(rm(x_2))

##------------------------------------------------------------------------------  
## Set reactive objects in custom environment //
##------------------------------------------------------------------------------

where <- new.env()

## Set object that other objects can have reactive bindings to //
setShinyReactive(id = "x_1", value = Sys.time(), where = where)
where$x_1
where$x_1 <- Sys.time()
where$x_1

## Set object with reactive bindings to 'x_1' //
setShinyReactive(id = "x_2", 
  value = reactive(where$x_1 + 60*60*24), 
  where = where
)
where$x_2
## --> 'where$x_1' + one day
(where$x_1 <- Sys.time())
where$x_2
## --> reactive

## Clean up //
suppressWarnings(rm(where))

##------------------------------------------------------------------------------  
## Mutltiple reactive bindings //
##------------------------------------------------------------------------------

x_1 <- setShinyReactive("x_1", 10)
x_2 <- setShinyReactive("x_2", 20)
x_3 <- setShinyReactive("x_3", value = reactive(x_1 + x_2 * 2))
x_3
## --> 'x_1' + 'x_2' * 2
(x_1 <- 100)
x_3
(x_2 <- 100)
x_3

## Clean up //
suppressWarnings(rm(x_1))
suppressWarnings(rm(x_2))
suppressWarnings(rm(x_3))

##------------------------------------------------------------------------------  
## Mutual reactive bindings //
##------------------------------------------------------------------------------

## NOTE
## To the best of my knowledge, the reactive paradigm implemented by the 
## shiny framework does not offer the possibility to define mutual reactive 
## bindings. 
## 
## Thus, something like 
##
##    "\\code{x_1} has reactive binding \\code{reactive{x_2 * 2}} 
##    and \\code{x_2} has reactive binding \\code{reactive{x_1 / 2}} 
##    where \\strong{both} objects can be modified via \\code{\\link{<-}}" 
##
## can not be specified. 
## The reason for this is that reactivity is implemented in a direct or 
## immediate manner: whenever \\code{x_1} that has a reactive binding to 
## \\code{x_2} is requested, it runs its reactive binding function even though 
## \\code{x_2} might not have changed at all. 
## Thus, mutual reactive bindings of the above form result in an 
## infinite recursion:

try(x_1 <- setShinyReactive("x_1", reactive(x_2 * 2)))
try(x_2 <- setShinyReactive("x_2", reactive(x_1 / 2)))

## If you would like to define mutual reactive bindings, you currently need to 
## use \\code{\\link[reactr]{setReactiveS3}} as it implements a value caching 
## mechanism that allows reactive functions only to be triggered when actually
## needed, i.e. when the referenced object has actually changed.

}
}
\author{
Janko Thyson \email{janko.thyson@rappster.de}
}
\references{
\url{http://github.com/Rappster/reactr}
}
\seealso{
\code{
  	\link[reactr]{setReactiveS3}
}
}

