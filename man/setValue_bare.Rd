% Generated by roxygen2 (4.0.1): do not edit by hand
\name{setValue_bare}
\alias{setValue_bare}
\title{Set Value (bare)}
\usage{
setValue_bare(id, value = NULL, where = .GlobalEnv, watch = character(),
  binding = substitute(expression()), binding_type = 1, mutual = FALSE,
  where_watch = where, .hash_id = "._HASH", .tracelevel = 0, ...)
}
\arguments{
\item{id}{\code{\link{character}}.
Name of the variable to set.}

\item{value}{\code{\link{ANY}}.
Variable value.}

\item{where}{\code{\link{environment}}.
Environment to set the variable in.}

\item{watch}{\\code{\link{character}}.
Name of a variable to be monitored}

\item{binding}{\code{\link{call}}
Function that defines the binding relationship between \code{id} and
\code{watch}. See details.}

\item{binding_type}{\code{\link{integer}} or \code{\link{numerical}}.
\itemize{
   \item{\code{1}:} {
   use \code{\link{makeActiveBinding}} to establish the binding
   }
   \item{\code{2}:} {
   use custom way of establishing the binding
   }
}}

\item{mutual}{\code{\link{logical}}.
\code{TRUE}: mutual binding contract;
\code{FALSE}: binding contract depends on \code{watch} being specified
or not (specified: \code{monitoring} contract;
not specified: \emph{monitored} contract)}

\item{.hash_id}{\code{\link{character}}.
Name of the auxiliary environment for caching hash values.
Default: \code{"._HASH"}. Keep it unless this name is already taken in
either \code{where} or \code{where_watch}.}

\item{.tracelevel}{\code{\link{numeric}}.
Verbosity level for tracing purposes. Value of \code{0} means
\emph{no tracing} whereas values of \code{> 0} can be used to fine
control tracing. The trace level can also be set as a global option when
using package \code{tracer} (\strong{not functional yet}).}

\item{...}{Further arguments to be passed to subsequent functions/methods.}
}
\description{
Sets a variable value in an environment.
}
\details{
If \code{binding_type = 1} (the current default), then the
actual binding is established via \code{\link[base]{makeActiveBinding}}.
This implies that the binding function \code{binding} needs to have a
specific structure as required by both \code{\link[base]{makeActiveBinding}}
and \code{setValue} itself. This in turn depends on what type of variable
you want to set: a variable that should be \emph{monitored} by other variables
(\emph{monitored}) or a variable that \emph{monitors} another
variable (\emp{monitoring}).

\itemize{
   \item{for \emph{monitored}} {

   }
   \item{for \emph{monitoring}} {
   }
}
}
\note{
\enumerate{
   \item{
   As binding functions require the use of \code{\link[base]{local}}, they need
to be wrapped by \code{\link[base]{substitute}} in order to delay their actual
evaluation to the actual call of \code{\link{makeActiveBinding}} inside
this function.}
   \item{
   When choosing \code{binding_type = 1}, it is recommended
   to also provide binding functions for "regular" variables as this will
   take care of all the details for the variable turning into a monitored
   variable later on. If you don't do that, you have to explicitly take care
   of reassigning the respective variable accordingly before it can be
   monitored by another variable
   }
}
}
\examples{
\dontrun{

################################################################################
## Binding type 1 //
################################################################################
 
## This is based on 'makeActiveBinding()' and respective boilerplate code 

where <- new.env()

## Set variable that can be monitored by others //
setValue_bare(id = "x_1", value = 10, where = where)

## Get current variable value //
where$x_1

##------------------------------------------------------------------------------
## Binding scenario: identical
##------------------------------------------------------------------------------

## Set variable that monitors 'x_1' //
## Binding contract: identical
setValue_bare(id = "x_2", where = where, watch = "x_1", binding = function(x) {x})

## When 'x_1' changes, 'x_2' changes accordingly:
## NOTE:
## When retrieving the value of 'x_2', you always retrieve a *cached* value 
## unless for the first retrieval after the observed variable 'x_1' has changed.
## That way, the function that binds 'x_1' to 'x_2' (the binding contract) 
## does not need to be executed each time, but only when it's actually required
where$x_1
where$x_2  ## cached value
where$x_1 <- 100
where$x_1  
where$x_2  ## value after executing binding function
where$x_2  ## cached value
where$x_2  ## cached value
where$x_1 <- 10
where$x_2  ## value after executing binding function
where$x_2  ## cached value
where$x_2  ## cached value

## NOTE:
## It does not matter if you set (or get) values via 'setValue_bare()' 
## (or 'getValue()') or via '<-'/'assign()' (or '$'/'get()')
setValue_bare(id = "x_1", value = 100, where = where)

where$x_1
where$x_2  ## value after executing binding function
where$x_2  ## cached value
getValue("x_2", where = where) ## cached value

##------------------------------------------------------------------------------
## Binding scenario: arbitrary functional relationship
##------------------------------------------------------------------------------

## Set variable that monitors 'x_1' //
setValue_bare(id = "x_3", where = where, watch = "x_1", binding = function(x) {x + 100})

where$x_1
where$x_3
where$x_1 <- 10
where$x_3 

##------------------------------------------------------------------------------
## Binding scenario: mutual
##------------------------------------------------------------------------------

## Set variables that are mutually bound //
where <- new.env()  

## Set '.tracelevel = 1' if you'd like to be able to understand what's actually
## going on
.tracelevel <- 0
    
setValue_bare(id = "x_1", where = where, watch = "x_2", 
  mutual = TRUE, .tracelevel = .tracelevel)
setValue_bare(id = "x_2", where = where, watch = "x_1", 
  mutual = TRUE, .tracelevel = .tracelevel
)

## Initial default values //
where$x_1
where$x_2

## Change any one of the mutually bound variables //
where$x_1 <- 300
where$x_1
where$x_2
where$x_2 <- 500
where$x_2
where$x_1

##------------------------------------------------------------------------------
## Binding scenario: multi-way
##------------------------------------------------------------------------------

## Set '.tracelevel = 1' if you'd like to be able to understand what's actually
## going on
.tracelevel <- 0

where <- new.env()      

## Set variables that are mutually bound //
setValue_bare(id = "x_1", where = where, watch = "x_2", 
  mutual = TRUE, .tracelevel = .tracelevel)
setValue_bare(id = "x_2", where = where, watch = "x_1", 
  mutual = TRUE, .tracelevel = .tracelevel
)
setValue_bare(id = "x_3", where = where, watch = "x_2", 
  binding = function(x) {x + 100}, .tracelevel = .tracelevel
)

where$x_1 <- 100
where$x_1
where$x_2
where$x_3

where$x_2 <- 200
where$x_1
where$x_2
where$x_3

## Disregarded:
where$x_3 <- 500
where$x_1
where$x_2
where$x_3

##------------------------------------------------------------------------------
## Binding scenario: multi-way with non-standard binding
##------------------------------------------------------------------------------

## Set '.tracelevel = 1' if you'd like to be able to understand what's actually
## going on
.tracelevel <- 0

where <- new.env()  

## Set variables that are mutually bound //
setValue_bare(id = "x_1", where = where, watch = "x_2", 
  mutual = TRUE, binding = function(x) {x/2}, .tracelevel = .tracelevel)
setValue_bare(id = "x_2", where = where, watch = "x_1", 
  mutual = TRUE, binding = function(x) {x * 2}, .tracelevel = .tracelevel
)

where$x_1 <- 100
where$x_1
where$x_2

where$x_2 <- 500
where$x_1
where$x_2

##------------------------------------------------------------------------------
## Binding scenario: complex data structure (kind of like Reference Classes)
##------------------------------------------------------------------------------

x_1 <- new.env()  
x_2 <- new.env()  

## Set regular "complex" variable 'x_1' //
setValue_bare(id = "field_1", value = TRUE, where = x_1)
setValue_bare(id = "field_2", value = data.frame(x_1 = 1:5, x_2 = letters[1:5]), 
  where = x_1)

## Set variable with bindings //
setValue_bare(id = "field_1", where = x_2, watch = "field_1", where_watch = x_1, 
         binding = function(x) {!x})
setValue_bare(id = "field_2", where = x_2, watch = "field_2", where_watch = x_1, 
         binding = function(x) {x[,-1,drop = FALSE]})

x_1$field_1
x_1$field_2
x_2$field_1
x_2$field_2

################################################################################
## Binding type 2 //
################################################################################

## This is the LEGACY (!) way of defining reactive bindings and is subject
## to being deprecated in furture package versions.

where <- new.env()  
  
setValue_bare(id = "x_1", value = Sys.time(), where = where, binding_type = 2)
getValue(id = "x_1", where = where)

binding <- substitute(function(x) {
  x + 60*60*24
})
setValue_bare(id = "x_2", where = where, binding = binding, watch = "x_1", 
         binding_type = 2)
getValue(id = "x_2", where = where)  
  
## Change value of monitored variable //
setValue_bare(id = "x_1", value = Sys.time(), where = where, binding_type = 2)
getValue(id = "x_1", where = where)  
getValue(id = "x_2", where = where) 

##------------------------------------------------------------------------------
## Profiling //
##------------------------------------------------------------------------------

require("microbenchmark")
    
## Binding type 1 //
where <- new.env()

res_bt_1 <- microbenchmark(
  "1" = setValue_bare(id = "x_1", value = 10, where = where),
  "2" = getValue(id = "x_1", where = where),
  "3" = setValue_bare(id = "x_2", where = where, watch = "x_1",
    binding = function(x) {x + 100}),
  "4" = getValue(id = "x_2", where = where),
  "5" = setValue_bare(id = "x_1", value = 100, where = where),
  "6" = getValue(id = "x_2", where = where),
  control = list(order = "inorder")
)
res_bt_1

## Binding type 2 //
where <- new.env()  

res_bt_2 <- microbenchmark(
  "1" = setValue_bare(id = "x_1", value = Sys.time(), where = where,
                 binding_type = 2),
  "2" = getValue(id = "x_1", where = where),
  "3" = setValue_bare(id = "x_2", where = where,
    binding = substitute(function(x) {
        x + 60*60*24
      }), watch = "x_1", binding_type = 2),
  "4" = getValue(id = "x_2", where = where),
  "5" = setValue_bare(id = "x_1", value = Sys.time(), where = where,
                 binding_type = 2),
  "6" = getValue(id = "x_2", where = where),
  control = list(order = "inorder")
)
res_bt_2

}
}
\author{
Janko Thyson \email{janko.thyson@rappster.de}
}
\references{
\url{http://github.com/Rappster/reactr}
}
\seealso{
\code{
  	\link[reactr]{setValue-character-ANY-environment-character-call-method}
}
}

